# Notes on learning from the book: Hacking, The art of exploitation

## `gcc`

```bash
gcc file.c      # Compiles and assembles file.c and puts the executable into a.out
gcc -m32 file.c # Compiles and assembles file.c for 32bit architectures
gcc -g file.c  # Compiles with extra debugging information. gdb gets access to source code if this flag used
```

## `objdump`

```bash
# objdump - display information from object files.

objdump -D executable
                        # [-D --disassemble-all]
objdump -D executable -M intel
                        # [-M options|--disassembler-options=options] is used to disassemble in intel style
objdump -D executable | grep main.: -An # Here n is number of lines after the match found
```

## `gdb`

Any (gdb) commands could be stored inside .gdbinit to execute those everytime gdb starts up.\
`gdb -q executable` -q for quiet. Does not print introductory copyright messages\
Inside gdb, gdb commands are written like this: **`(gdb) COMMAND`**\

### **Basic Commands:**

- `set disassembly-flavor intel` sets disassembly language type to intel
  - `set dis intel` also works fine
- `disassemble <label> / disass <label>` Disassembles the code of specified label
- `list` Shows the source code if compiled correctly with `-g` flag.
- `break <label>` make a breakpoint at the specified label
  - `delete` Deletes all the breakpoints
- `run` starts running the program till the breakpoint. Restarts the program if used more than once in one execution cycle
- `continue / cont` continue the execution till the next breakpoint
- `info registers` Shows the condition of the registers. {short form i r}
- `info register <registerName>` Shows the condition of the specified register
  - short form `i r registername` ex: `i r eip`
- `nexti` or `ni` Execute next instruction
- `bt` For backtracking by looking at stack for return address
- `quit` # Quits the gdb session

### **Memory inspection**

- `x` Is short for examine.
- `x/nx <address>` Examine the memory in hex format. `n` refers to how many memory units to show.
  - A memory unit is 4 bytes or a WORD long. But can be modified.
  - `x/nx $registername` To examine the hex value the register is holding. `$register` means the value the register is holding.
- `x/no <address>` Examine the memory in octal format
- `x/nu <address>` Examine the memory in standard unsigned base-10 or decimal format
- `x/nt <address>` Examine the memory in binary format
- `x/nc <address>` Examine the memory in unsigned base-10 format with ascii value on. For character inspection
- `x/s <address>` shows the string representation in the memory address
- `x/ni $<register>/<address>` show the instructions at the position the register is pointing to.
- `print $<register>` Print the memory location the register is pointing to and the result is stored in a temp var like $1

### Modifying memory Units

- `x/8xb $eip` Will show 8 memory units of a byte from the value eip is storing. Eip is storing a memory address.

  - `h` will make memory unit half the size of word (2b)
  - `w` will make the memory unit size of a word (4b)
  - `g` will make the memory unit size of a giant (8b)

## Assembly Language stuffs

- EAX -> Accumulator
- ECX -> Counter
- EDX -> Data
- EBX -> Base
- ESP -> Stack Pointer {Used as pointers}
- EBP -> Base Pointer {Used as pointers}
- ESI -> Source Index
- EDI -> Destination Index
- EIP -> Instruction Pointer Register

The first four are mainly used for storing temporary variables for the cpu.\
The other four is used mostly as pointers or index.\
The last two are used to point to source and destination when data needs to read from or written to.

## Instructions related

- Schema: `operation <destination> <source>`
- `cmp DWORD PTR [ebp-4],0x9` means:
  - Go to ebp-4 address. Here ebp stores the base memory address
  - Compare the value stored there (DWORD->Double Word->4byte) with 0x09
- `cmp DWORD PTR [ebp-4], 0x09` `jle 0xaddress`
  - Jump if the value in ebp-4 is less than or equal to 0x09
